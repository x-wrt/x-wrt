From: Mieczyslaw Nalewaj <namiltd@yahoo.com>
Date: Sun, 26 Oct 2025 10:36:02 +0100
Subject: [PATCH] mt7620: avoid direct jal imm26 in random helper; conditional stack align

This patch adds a targeted a workaround for the mt7620 platform and a safeguard
in the exec path. On mt7620 we force the compiler to emit an indirect call
(load address into a register + jalr) when calling the small random helpers
used by the constant-folding fast path of get_random_u32_below().
This avoids embedding a 26-bit immediate jump target in a direct `jal`
instruction, which can be vulnerable to symptoms such as sporadic incorrect
jump targets (e.g. wrong high-nibble addresses like 0x70360944 vs 0x80360944),
intermittent kernel oopses/crashes or hangs, corrupted or nonsensical
backtraces, and occasionally "half-written" instructions observed under high
load or with interrupts enabled; these symptoms are typically caused by partial
writes, missing I-cache synchronization, or buggy runtime patching of .text.

The patch also avoids applying arch_align_stack() / PAGE_ALIGN() in the exec
path on CONFIG_NET_RALINK_MT7620 builds (conditional stack_top adjustment),
reducing the use of the affected code sequence on the platform while the
root cause (non-atomic text patching / I-cache sync issues) is addressed.
Many upstream arch ports including mt7620 implement only micro-randomization
inside arch_align_stack() (random offset < PAGE_SIZE, then align-down to
a small alignment such as 8/16 bytes). In callers that immediately
apply PAGE_ALIGN() (align-up to a page boundary) that micro-offset
is rounded back to the original page boundary, so invoking
arch_align_stack() and performing the subsequent page-granular
adjustments is pointless.

Both changes are conservative and platform-specific workarounds; they do not
change the algorithmic behavior of get_random_u32_below() and are intended to
reduce the likelihood of control-flow corruption while a proper fix to the
underlying patching/synchronization issues is implemented.

Signed-off-by: Mieczyslaw Nalewaj <namiltd@yahoo.com>
---

--- a/fs/exec.c
+++ b/fs/exec.c
@@ -750,8 +750,10 @@ int setup_arg_pages(struct linux_binprm
 	mm->arg_start = bprm->p - stack_shift;
 	bprm->p = vma->vm_end - stack_shift;
 #else
+#ifndef CONFIG_NET_RALINK_MT7620
 	stack_top = arch_align_stack(stack_top);
 	stack_top = PAGE_ALIGN(stack_top);
+#endif
 
 	if (unlikely(stack_top < mmap_min_addr) ||
 	    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -73,17 +73,45 @@ static inline u32 get_random_u32_below(u
 	BUILD_BUG_ON_MSG(!ceil, "get_random_u32_below() must take ceil > 0");
 	if (ceil <= 1)
 		return 0;
-	for (;;) {
-		if (ceil <= 1U << 8) {
+	if (ceil <= 1U << 8) {
+#ifdef CONFIG_NET_RALINK_MT7620
+		typedef u8 (*getrnd_t)(void);
+		volatile getrnd_t rnd_fn = (getrnd_t)get_random_u8;
+#endif
+		for (;;) {
+#ifdef CONFIG_NET_RALINK_MT7620
+			u32 mult = ceil * rnd_fn();
+#else
 			u32 mult = ceil * get_random_u8();
+#endif
 			if (likely(is_power_of_2(ceil) || (u8)mult >= (1U << 8) % ceil))
 				return mult >> 8;
-		} else if (ceil <= 1U << 16) {
+		}
+	} else if (ceil <= 1U << 16) {
+#ifdef CONFIG_NET_RALINK_MT7620
+		typedef u16 (*getrnd_t)(void);
+		volatile getrnd_t rnd_fn = (getrnd_t)get_random_u16;
+#endif
+		for (;;) {
+#ifdef CONFIG_NET_RALINK_MT7620
+			u32 mult = ceil * rnd_fn();
+#else
 			u32 mult = ceil * get_random_u16();
+#endif
 			if (likely(is_power_of_2(ceil) || (u16)mult >= (1U << 16) % ceil))
 				return mult >> 16;
-		} else {
+		}
+	} else {
+#ifdef CONFIG_NET_RALINK_MT7620
+		typedef u32 (*getrnd_t)(void);
+		volatile getrnd_t rnd_fn = (getrnd_t)get_random_u32;
+#endif
+		for (;;) {
+#ifdef CONFIG_NET_RALINK_MT7620
+			u64 mult = (u64)ceil * rnd_fn();
+#else
 			u64 mult = (u64)ceil * get_random_u32();
+#endif
 			if (likely(is_power_of_2(ceil) || (u32)mult >= -ceil % ceil))
 				return mult >> 32;
 		}
